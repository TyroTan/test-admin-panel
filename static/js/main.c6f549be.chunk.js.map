{"version":3,"sources":["utils/index.ts","views_helper/asyncComponent.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["getCurrentSession","a","user","emptyUser","token","user_id","email","is_admin","JSON","parse","localStorage","getItem","e","length","setCurrentSession","userData","data","stringify","setItem","logoutAsync","asyncComponent","parentProps","importComponent","AsyncFunc","props","mounted","state","component","authed","authedButRedirectTo","this","Nprogress","start","Component","default","requiresAuth","console","log","done","ifAuthedRedirectTo","setState","pathname","location","to","type","rows","ready","from","withRouter","App","path","Boolean","window","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c6f549be.chunk.js","sourcesContent":["const getCurrentSession = async (): Promise<UserData> => {\n  const emptyUser = {\n    token: '',\n    user_id: 0,\n    email: '',\n    is_admin: false,\n  } as UserData;\n  let user = emptyUser as UserData;\n\n  try {\n    user = JSON.parse(localStorage.getItem('userData') ?? '');\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n\n  return user?.token?.length ? user : emptyUser;\n\n  // return {\n  //   // idToken: '123',\n  //   // email: 'tantyrohunter@email.com',\n  //   idToken: '',\n  //   email: '',\n  // };\n};\n\nconst setCurrentSession = async (userData: UserData): Promise<void> => {\n  try {\n    const data =\n      typeof userData === 'string' ? userData : JSON.stringify(userData);\n    localStorage.setItem('userData', data);\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  return;\n};\n\nconst logoutAsync = async (): Promise<boolean> => {\n  try {\n    localStorage.setItem('userData', '');\n    return true;\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n\n  return false;\n};\n\nexport default getCurrentSession;\nexport { getCurrentSession, setCurrentSession, logoutAsync };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport React, {\n  Component,\n  FC,\n  ReactElement,\n  ComponentClass,\n  FunctionComponent,\n} from 'react';\nimport Nprogress from 'nprogress';\nimport ReactPlaceholder from 'react-placeholder';\nimport 'nprogress/nprogress.css';\nimport 'react-placeholder/lib/reactPlaceholder.css';\nimport { getCurrentSession } from 'utils/';\nimport { withRouter, Redirect } from 'react-router-dom';\nimport { RouteComponentProps, StaticContext } from 'react-router';\n\ntype AsyncComponentType =\n  | ComponentClass<any, any>\n  | FunctionComponent<any>\n  | ComponentClass<RouteComponentProps<any, StaticContext, any>, any>\n  | FunctionComponent<RouteComponentProps<any, StaticContext, any>>\n  | undefined;\n\nexport default function asyncComponent(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parentProps: any,\n  importComponent: () => DynamicImportType | any,\n): Component {\n  if (!importComponent) importComponent = parentProps;\n\n  interface AsyncFuncProps {\n    mounted: boolean;\n  }\n\n  interface AsyncFuncState {\n    component: FC | Component | null;\n    authed: boolean;\n    authedButRedirectTo: string;\n  }\n\n  class AsyncFunc extends Component<\n    AsyncFuncProps & AsyncFuncState & RouteComponentProps\n  > {\n    public mounted = false;\n    public state = {\n      component: null,\n      authed: true,\n      authedButRedirectTo: '',\n    };\n    public constructor(\n      props: AsyncFuncProps & AsyncFuncState & RouteComponentProps,\n    ) {\n      super(props);\n    }\n\n    // public componentWillMount(): void {\n    //   Nprogress.start();\n    // }\n\n    public componentWillUnmount(): void {\n      this.mounted = false;\n    }\n\n    public async componentDidMount(): Promise<void> {\n      Nprogress.start();\n      this.mounted = true;\n      const { default: Component } = await importComponent();\n\n      try {\n        if (parentProps.requiresAuth === true) {\n          const authed = await getCurrentSession();\n          console.log('authedauthed', authed);\n          Nprogress.done();\n\n          if (authed && authed.token) {\n            if (this.mounted) {\n              if (\n                parentProps.ifAuthedRedirectTo &&\n                typeof parentProps.ifAuthedRedirectTo === 'string'\n              ) {\n                this.setState({\n                  authedButRedirectTo: parentProps.ifAuthedRedirectTo,\n                });\n\n                return;\n              }\n\n              console.log('typeof Component', typeof Component);\n\n              this.setState({\n                component: <Component {...this.props} />,\n              });\n            }\n          } else {\n            this.setState({\n              authed: false,\n              component: <Component {...this.props} />,\n            });\n            return;\n          }\n        }\n        // const { default: Component } = await importComponent();\n        // Nprogress.done();\n        // if (this.mounted) {\n        //   this.setState({\n        //     component: <Component {...this.props} />\n        //   });\n        // }\n      } catch (e) {\n        // eslint-disable-next-line no-console\n        console.log('error, redirect to login', e);\n        this.mounted = false;\n        Nprogress.done();\n        // this.setState({\n        //   authed: false\n        // });\n      }\n    }\n\n    public render(): ReactElement {\n      const Component = this.state.component || <div />;\n      const { pathname } = this.props.location;\n\n      if (this.state.authed === true) {\n        if (this.state.authedButRedirectTo) {\n          return (\n            <Redirect\n              to={{\n                pathname: this.state.authedButRedirectTo,\n              }}\n            />\n          );\n        }\n\n        return (\n          <ReactPlaceholder type=\"text\" rows={7} ready={Component !== null}>\n            {Component}\n          </ReactPlaceholder>\n        );\n      } else {\n        if (pathname === '/login') {\n          return (\n            <ReactPlaceholder type=\"text\" rows={7} ready={Component !== null}>\n              {Component}\n            </ReactPlaceholder>\n          );\n        } else {\n          return (\n            <Redirect\n              to={{\n                pathname: '/login',\n                state: { from: this.props.location },\n              }}\n            />\n          );\n        }\n      }\n    }\n  }\n\n  return (withRouter(AsyncFunc) as unknown) as any;\n}\n","import React from 'react';\nimport {\n  // BrowserRouter as Router,\n  Route,\n  Switch,\n  BrowserRouter,\n  Redirect,\n  // Redirect,\n} from 'react-router-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport 'bs4dashboard/assets/css/animate.min.css';\nimport 'bs4dashboard/assets/sass/light-bootstrap-dashboard-react.scss?v=1.3.0';\nimport 'bs4dashboard/assets/css/demo.css';\nimport 'bs4dashboard/assets/css/pe-icon-7-stroke.css';\n// import './App.css';\nimport asyncComponent from './views_helper/asyncComponent';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst App: React.FC = (): any => {\n  return (\n    <BrowserRouter>\n      <Switch>\n        <Route\n          path=\"/login\"\n          component={\n            asyncComponent(\n              {\n                requiresAuth: true,\n                ifAuthedRedirectTo: '/admin/dashboard',\n              },\n              (): DynamicImportType => import('containers/LoginForm'),\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            ) as any\n          }\n          // render={(props): React.ReactElement => <AdminLayout {...props} />}\n        />\n        <Route\n          path=\"/admin\"\n          component={\n            asyncComponent(\n              {\n                requiresAuth: true,\n              },\n              (): DynamicImportType => import('bs4dashboard/layouts/Admin.jsx'),\n              // import('src/bs3dashboard/layouts/Admin')\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            ) as any\n          }\n          // render={(props): React.ReactElement => <AdminLayout {...props} />}\n        />\n        <Route\n          path=\"/admin/dashboard\"\n          component={\n            asyncComponent(\n              {\n                requiresAuth: true,\n              },\n              (): DynamicImportType => import('bs4dashboard/layouts/Admin.jsx'),\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            ) as any\n          }\n          // render={(props): React.ReactElement => <AdminLayout {...props} />}\n        />\n\n        <Redirect from=\"/\" to=\"/admin/dashboard\" />\n\n        <Route\n          component={\n            asyncComponent(\n              {\n                requiresAuth: true,\n                ifAuthedRedirectTo: '/admin/dashboard',\n              },\n              (): DynamicImportType => import('containers/LoginForm'),\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            ) as any\n          }\n        />\n      </Switch>\n    </BrowserRouter>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}